## 一、面向对象程序设计的基本特点

### 1.1 抽象

- **指对具体问题（对象）进行概括，*抽出一类对象的公共性质并加以描述的过程***

- **数据抽象**

	- 描述某类对象的属性或状态，即此类对象与其他类对象的区别

- **行为抽象**

	- 描述某类对象的共同行为或功能特征

		以人为例，对其进行抽象。
		共同属性：姓名、性别、年龄等等，则数据抽象：

		`string name, string sex, int age`

		共同的行为：吃饭、走路、学习等等，则行为抽象：

		`eat(), walk(), study()`

### 1.2 C++面向对象三大特性

1. <font color="#dd0000">**封装**</font>：**将数据和操作数据的函数代码进行有机结合**，形成 “ 类 ”，其中的数据和函数都是类的成员
2. <font color="#dd0000">**继承**</font>：允许在**保存原有类特性**的基础上，进行**更具体、更详细的说明**
3. <font color="#dd0000">**多态**</font>：一段程序能**处理多种类型对象**的能力

## 二、类和对象

### 2.1 基本概念

1. **类（class）**
   - **对逻辑上相关的函数和数据的封装，是对问题的抽象描述**
   - 在面向对象程序设计中，*程序模块是由类构成的*
2. **对象（object）**
   - **是具有class类型的变量**
   - C++认为万事万物皆为对象，对象具有**属性**和**行为**
   - **具有相同性质的对象，可以抽象为类**
     - 例如：人属于人类，人作为对象，属性包括姓名、性别、年龄等，行为包括吃饭、走路、学习等
     - 类中的属性和行为，统称为**成员**
       - 属性：**成员属性，成员变量**
       - 行为：**成员函数，成员方法**
   - 创建对象的过程叫**实例化**，新创建的对象叫**实例（instance）**

### 2.1 封装

#### 2.1.1 封装的目的

**增强安全性和简化编程**，使用者不需要具体了解实现细节，只需要通过**外部接口**，以**特定的权限**进行访问，使用类的成员

#### 2.1.2 封装的意义

1. 将**属性和行为作为一个整体**，表现生活中的事务

   - 语法：

     ```c++
     class ClassName {
         访问权限：
             属性
             行为
     }
     ```

   - 例子：

     <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202206050032573.png" alt="image-20220605003216489" style="zoom: 33%;" />

     ```c++
     // 封装一个圆类，求圆的面积和周长
     class Circle{
     public:
         // 属性：半径
         int radius;
         // 行为：获取圆面积；获取圆周长
         double findArea();
         double findPerimeter();
     };
     
     int main(){
         Circle c;
         c.radius = 10;
         
         std::cout << "圆的面积：" << c.findArea() << std::endl;
         std::cout << "圆的周长：" << c.findPerimeter() << std::endl;
     }
     ```

2. 将属性和行为加以**权限控制**

   - **成员访问权限**
     - public、protected和private是**访问权限修饰符**
       - 被public修饰的属性和函数可以在类内部与类外部被访问
       - 被protected和private修饰的属性和函数只能在类内部被访问
     - **成员函数可以访问本类中任何成员**
       - 一般做法是*将需要被外界调用的成员函数指定为public*，它们是**类的对外接口**
     - 有的函数并*不是准备为外界调用的*，而是*为本类中的成员函数所调用的*，就*应该将它们指定为private*
     - 一般将**属性定义为私有，行为定义为公有**

#### 2.1.3 类的定义与实例化

```c++
// 类名称通常将首字母写成大写
class 类名{
public:
    公有成员（外部接口） // 任何外部函数都可访问
private:
    私有成员		   // 只允许本类中的函数访问
protected:
    保护型成员		  // 与继承有关
}

// 实例化一个对象 (创建对象的过程叫实例化，新创建的对象叫实例instance)
类名	对象名;

// 访问数据成员
对象名.数据成员名

// 调用函数成员
对象名.函数成员名（参数表）
```

##### 2.1.3.1 成员函数

- 描述类的行为，对封装的数据进行操作的方法

- **函数的原型声明要写在类体中，函数的具体实现写在类定义外**

- **类成员函数的默认值，一定要写在类定义中**

- 语法：

	```C++
	返回值类型	类名::函数成员名（参数表）{
	    
	    函数体
	
	}
	```

	示例：

	```c++
	#include <iostream>
	using namespace std;
	class Clock {
	public:
	    void setTime(int newH = 0, int newM = 0, int newS = 0);
	    void showTime();
	private:
	    int hour, minute, second;    
	};
	
	// 类成员函数setTime
	void Clock::setTime(int newH, int newM, int newS) {
	    hour = newH;
	    minute = newM;
	    second = newS;
	}
	// 类成员函数showTime
	void Clock::showTime() {
	    cout << hour << ":" << minute << ":" << second;
	}
	
	int main() {
	    Clock myClock;	// 定义对象
	    myClock.setTime(8, 30, 30);	// 通过“.”操作符实现对象成员函数的访问
	    myClock.showTime();
	    return 0;
	}
	```

#### 2.1.4 多文件编写代码

##### 2.1.4.1 多文件结构

通常一个项目至少划分为3个文件：

- **类定义文件（*.h文件）**
  - 写类的声明，包括了所有函数的函数头
- **类实现文件（*.cpp文件）**
  - 写类的定义
  - 注意要引用类定义文件，`#include *.h`
  - 定义成员函数时函数名称前要加上类名：`类名::函数`，例如：`Clock::setTime`
- **类使用文件（*.cpp，主函数文件）**
  - 创建类对象并进行调用
  - 注意要引用类定义文件，`#include *.h`

更为复杂的程序，可以将每一个类都用单独的定义和实现文件

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202206070935803.png" alt="image-20220607093523738" style="zoom:50%;" />

##### 2.1.4.2 例子：点和圆的关系

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/image-20230509102226707.png" alt="image-20230509102226707" style="zoom:50%;" />

- **所有代码在同一个源文件内**

  ```c++
  # include <iostream>
  using namespace std;
  
  class Point { //点类
  public:
      void setX(int x) { m_X = x; } //设置x
      int getX() { return m_X; }    //获取x
      void setY(int y) { m_Y = y; } //设置y
      int getY() { return m_Y; }    //获取y
  private:
      int m_X;
      int m_Y;       
  };
  
  class Circle { //圆类
  public: 
      void setR(int r) { m_R = r; }				        //设置半径    
      int getR(){ return m_R; }						   //获取半径    
      void setCenter(Point center){ m_Center = center; }	 //设置圆心   
      Point getCenter(){ return m_Center; } 				//获取圆心   
  private:
      int m_R;    //半径
     
      //
      //在类中可以让另一个类作为本类的成员
      //
      Point m_Center;  //圆心      
  };
  
  //判断点和圆的关系
  void isInCircle(Circle &c, Point &p){
      //计算两点之间距离平方
      int distance = (c.getCenter().getX() - p.getX()) * (c.getCenter().getX() - p.getX()) +
                     (c.getCenter().getY() - p.getY()) * (c.getCenter().getY() - p.getY());
      //计算半径的平方
      int rDistance = c.getR() * c.getR();
      
     //判断关系
     if(distance == rDistance){
         cout << "点在圆上" << endl; 
     }else if(distance > rDistance){
         cout << "点在圆外" << endl;
     }else{
         cout << "点在圆内" << endl;
     }               
  }
  
  int main(){
      //创建圆
      Circle c;
      c.setR(10);
      Point center;
      center.setX(10);
      center.setY(0);
      c.setCenter(center);
      //创建点
      Point p;
      p.setX(10);
      p.setY(10);
      //判断关系
      isInCircle(c, p);
  }
  ```

- **多文件编写**

  - 点类头文件point.h（写点类的类声明）

    ```c++
    # pragma once
    # include <iostream>
    using namespace std;
    
    class Point { //点类
    public:
        void setX(int x); //设置x
        int getX();       //获取x
        void setY(int y); //设置y
        int getY();       //获取y
    private:
        int m_X;
        int m_Y;       
    };
    ```

  - 点类源文件point.cpp（写点类的类定义）

    ```c++
    # include "point.h"
    
    //设置x
    void Point::setX(int x) { 
        m_X = x; 
    } 
    //获取x
    int Point::getX() { 
        return m_X; 
    }    
    //设置y
    void Point::setY(int y) { 
        m_Y = y; 
    } 
    //获取y
    int Point::getY() { 
        return m_Y; 
    }    
    ```

  - 圆类头文件circle.h（写圆类的类声明）

    ```c++
    # pragma once
    # include <iostream>
    using namespace std;
    
    class Circle { //圆类
    public: 
        void setR(int r) { m_R = r; }				        //设置半径    
        int getR(){ return m_R; }						   //获取半径    
        void setCenter(Point center){ m_Center = center; }	 //设置圆心   
        Point getCenter(){ return m_Center; } 				//获取圆心   
    private:
        int m_R;    //半径
        Point m_Center;  //圆心      
    };
    ```

  - 圆类源文件circle.cpp（写圆类的类定义）

    ```c++
    # include "circle.h"
    
    //设置半径
    void Circle::setR(int r){
        m_R = r;
    }
    //获取半径
    int Circle::getR(){
       return m_R;
    }
    //设置圆心
    void Circle::setCenter(Point center){
        m_Center = center;
    }
    //获取圆心
    Point Circle::getCenter(){
        return m_Center;
    }
    ```

  - 主函数main.cpp（调用类）

    ```c++
    # include <iostream>
    # include "circle.h"
    # include "point.h"
    using namespace std;
    
    //判断点和圆的关系
    void isInCircle(Circle &c, Point &p){
       //计算两点之间距离平方
       int distance = (c.getCenter().getX() - p.getX()) * (c.getCenter().getX() - p.getX()) +
                       (c.getCenter().getY() - p.getY()) * (c.getCenter().getY() - p.getY());
       //计算半径的平方
       int rDistance = c.getR() * c.getR(); 
       //判断关系
       if(distance == rDistance){
           cout << "点在圆上" << endl; 
       }else if(distance > rDistance){
           cout << "点在圆外" << endl;
       }else{
           cout << "点在圆内" << endl;
       }               
    }
    
    int main(){
        //创建圆
        Circle c;
        c.setR(10);
        Point center;
        center.setX(10);
        center.setY(0);
        c.setCenter(center);
        //创建点
        Point p;
        p.setX(10);
        p.setY(10);
        //判断关系
        isInCircle(c, p);
    }
    ```

### 2.2 对象的初始化和清理

- C++中的面向对象来源于生活，每个对象也都会有**初始设置以及对象销毁前的清理数据的设置**，对象的**初始化和清理**也是两个非常重要的安全问题

  1. *一个对象或者变量没有初始状态，对其使用后果是未知的*
  2. *使用完一个对象或变量，没有及时清理，也会造成一定的安全问题*

  - 例如：生活中我们买的电子产品基本都会有出厂设置，在某一天我们不用时也会删除掉自己的信息数据以保证隐私

- 每个对象与其他对象的区别：

  - 外在区别即对象名称
  - 内在区别则是对象自身属性值，即数据成员的值

- C++利用**构造函数**和**析构函数**解决上述问题，这两个函数会被**编译器自动调用**，完成对象初始化和清理工作

  - 对象的初始化和清理工作是编译器强制要我们做的事情，如果没有提供构造和析构，编译器会提供该函数的空实现
  - <font color="#dd0000">**构造函数：创建对象时，为对象的成员属性赋值**</font>
  - <font color="#dd0000">**析构函数：对象销毁前，系统自动调用，执行一些清理工作**</font>

#### 2.2.1 构造函数（constructor）

##### 2.2.1.1 定义

```c++
类名（参数说明）{
    初始化代码
}
```

```c++
# include <iostream>
using namespace std;

// 对象的初始化和清理
// 构造函数，进行初始化操作
class Person {
public:
	//定义构造函数，编译器自动调用
	Person() {
		cout << "Person 构造函数调用" << endl;
	}
};

int main() {
	Person p;
}
```

##### 2.2.1.2 特点

1. **构造函数的名字必须与类的名字相同**
2. 定义构造函数时**不能指定返回类型**
3. 构造函数的代码与其他函数一样，但**一般不直接调用（不显示调用）**
4. 创建类的一个新对象时，会隐式地自动调用构造函数
   - **当声明一个新对象时，程序会自动调用该对象所属类中定义的构造函数来初始化这个对象的状态**
5. *若在定义类时没有定义构造函数，C++会自动为该类创建一个缺省（default）的构造函数*。该缺省构造函数没有任何形式参数，且函数体为空

##### 2.2.1.3 有参构造函数和无参构造函数

1. 构造函数定义中，**在冒号之后、函数体之前是初始化列表**
2. 有参构造函数：
   - **定义构造函数时带有形参，那么建立对象时必须要给出初始值，用于作为调用构造函数时的实参**
3. 无参构造函数（默认构造函数）：
   - **调用时可以不需要参数的构造函数都是无参构造函数**
     - 当**不定义构造函数时**，编译器自动产生默认构造函数
     - 在类中可以**自定义无参数的构造函数**，也是默认构造函数
     - **全部参数都有默认形参值的构造函数**，也是默认构造函数
4. **一个系统只能有一个默认构造函数**

示例：

```c++
#include <iostream>
using namespace std;    

class Clock{
public:
    // 定义了两个Clock构造函数，即为构造函数的重载
    Clock(int newH, int newM, int newS);	// 定义有参构造函数
    Clock();							  // 定义无参构造函数
    /*
    // 每个参数都有默认值，属于默认构造参数
    Clock(int newH = 0, int newM = 0, int newS = 0);
    调用方式：
    Clock c1(8, 30, 30);
    Clock c2(8);
    Clock c3;	// 这种方式也可以使用Clock()定义无参构造函数，因此类中不可同时存在这两种构造函数的定义方式
    */
    
    void setTime(int newH, int newM, int newS);
    void showTime();
private:
    int hour, minute, second;
};

// 有参构造函数的实现
// 冒号之后，函数体之前部分称为 初始化成员列表
// 将初始化传入的三个数据newH、newM、newS的值分别给hour、minute、second
Clock::Clock(int newH, int newM, int newS):hour(newH), minute(newM), second(newS){ 
}
/* 等价于
Clock::Clock(int newH, int newM, int newS){
    hour = newH;
    minute = newM;
    second = newS;
}
*/

// 无参构造函数的实现
Clock::Clock(): hour(1), minute(1), second(1){
}
/* 等价于
Clock::Clock(){
    hour = 1;
    minute = 1;
    second = 1;
}
*/

// 成员函数
void Clock::setTime(int newH, int newM, int newS){
    hour = newH;
    minute = newM;
    second = newS;
}
void Clock::showTime(){
    cout << hour << ":" << minute << ":" << second << endl;
}

int main(){
    Clock myClock1;		        // 定义对象，此时自动调用无参构造函数
    myClock1.showTime();
    
    Clock myClock2(8, 3, 30);	// 定义对象，此时自动调用有参构造函数
    myClock2.showTime();
    
    return 0;
}
```

##### 2.2.1.4 复制构造函数

1. 具有一般构造函数的所有特性，其**形参是本类的对象的引用**

2. 作用：**使用一个已经存在的对象，该对象由复制构造函数的形参指定，去初始化 *同类* 的一个新对象**

3. 语法（**类内声明，类外实现**）：

   ```c++
   class 类名 {
   public:
       类名(形参表);		// 构造函数
       类名(类名 &对象名);   // 复制构造函数
       ...
   };
   
   // 复制构造函数的定义
   类名::类名(类名 &对象名){ 
   }
   ```

4. 复制构造函数的三种使用情形

   - **定义一个对象时，以本类另一个对象作为初始值**

     ```c++
     Point a(10, 20);
     Point b = a;
     ```

   - **传参**

     ```c++
     void fun1(Point p){
         cout << p.getX() << endl;
     }
     
     // 调用语句
     fun1(b);
     ```

   - **函数值返回**

     ```c++
     Point fun2(){
         return Point(1, 2);
     }
     
     // 调用语句
     b = fun2();
     ```

#### 2.2.2 析构函数（destructor）

##### 2.2.2.1 定义

```c++
~类名() {
    
}
```

##### 2.2.2.2 特点

1. 析构函数的名字必须是**在类名前加上一个波纹号“~”**，以区别于构造函数
2. 定义析构函数时也**不能指定返回类型**
3. 在对象消亡时，隐式地自动调用析构函数
   - **当一个对象作用结束时，程序会自动调用该对象所属类中定义的析构函数来清除这个对象所占的存储空间**
4. 若在定义类时没有定义析构函数，C++会自动为该类创建一个缺省的析构函数。这个缺省析构函数没有任何形式参数，且函数体为空

##### 2.2.2.3 析构函数的实现

```c++
#include <iostream>
using namespace std;

class DemoClass{
public:
    DemoClass(int i);	// 函数名与类名一样，因此是构造函数
    ~DemoClass();		// 函数名与类名一样，且开头有~，因此是析构函数   	
};

// 构造函数的实现
DemoClass::DemoClass(int i){
    cout << "Initial value is" << i << endl;
}

// 析构函数的实现
DemoClass::~DemoClass(){
    cout << "destructor" << endl;
}

void main(){
    DemoClass obj(30);	// 创建对象，同时自动调用构造函数DemoClass()
    cout << "This is the end main()" << endl;
    return;	// 函数执行结束，创建的对象生命结束，自动调用析构函数~DemoClass()
}
```

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202206052238503.png" alt="image-20220605223805453" style="zoom:50%;" />

#### 2.2.3 深拷贝和浅拷贝

**浅拷贝：简单的赋值拷贝操作**

- 带来的问题：**内存的重复释放** > 解决方法：深拷贝

**深拷贝：在堆区重新申请空间，进行拷贝操作**

- **如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题**

```c++
class Person{
public:
    Person()
    {
        cout << "Person的默认构造函数调用" << endl;
    }
    
    Person(int age, int height)
    {
        m_Age = age;
        m_Height = new int(height);
        cout << "Person的有参构造函数调用" << endl;
    }
    
    // 自己实现拷贝构造函数, 解决浅拷贝带来的问题
    Person(const Person &p)
    {
        cout << "Person 拷贝构造函数调用" << endl;
        m_Age = p.m_Age;
        
        // 浅拷贝
        // m_Height = p.m_Height; 编译器默认实现就是这行代码
        
        // 深拷贝操作, 重新开辟一个空间
        m_Height = new int(*p.m_Height);
    }
    
    ~Person()
    {
        // 析构代码, 将堆区开辟数据做释放操作
        if (m_Height != NULL)
        {
            delete m_Height;
            n_Height = NULL;
        }
        cout << "Person的析构函数调用" << endl;
    }
    
    int m_Age;	//年龄
    int *m_Height; // 身高 (在堆区开辟一个空间)
}

void test01()
{
    Person p1(18, 160);
    cout << "p1的年龄为：" << p1.m_Age << "身高为：" << *p1.m_Height << endl;
    
    Person p2(p1);	// 编译器给了一个浅拷贝操作
    cout << "p2的年龄为：" << p2.m_Age << "身高为：" << *p2.m_Height << endl;
}

int main()
{
    test01();
}
```

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202502241554962.png" alt="image-20250224155432402" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202502241559661.png" alt="image-20250224155942581" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202502241600044.png" alt="image-20250224160020966" style="zoom:50%;" />

#### 2.2.4 类对象作为类成员

- C++类中的成员可以是另一个类的对象，称该成员为**对象成员**
- 例如：B类中有对象A作为成员，A为对象成员

```c++
class A{}
class B{
    A a;
}
```

- 创建B对象时，A与B的构造和析构的顺序：
  - **构造顺序：先调用对象成员的构造，再调用本类的构造**
  - **析构顺序：与构造顺序相反**

```c++
# include <iostream>
# include <string>
using namespace std;

// 手机类
class Phone {
public:
	Phone(string name) {
		m_PhoneName = name;
		cout << "Phone构造" << endl;
	}

	~Phone() {
		cout << "Phone析构" << endl;
	}

	string m_PhoneName;
};

// 人类
class Person {
public:

	Person(string name, string pName) : m_Name(name), m_Phone(pName) {
		cout << "Person构造" << endl;
	}

	~Person() {
		cout << "Person析构" << endl;
	}

	void playGame() {
		cout << m_Name << " 使用" << m_Phone.m_PhoneName << " 牌手机！" << endl;
	}

	string m_Name;	// 姓名
    
	Phone m_Phone;	// 手机，手机类对象（对象成员）
};

void test01() {
	// 当类中成员是其他类对象时，我们称该成员为 对象成员
	// 构造的顺序是：先调用对象成员的构造，再调用本类构造
	// 析构的顺序与构造相反
	Person p("张三", "苹果X");
	p.playGame();
}

int main() {
	test01();
}
```

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202210170058520.png" alt="image-20221017005820482" style="zoom:50%;" />

#### 2.2.5 静态成员

##### 2.2.5.1 对象的生存期

- 生存期：*对象从诞生到结束的这段时间*
- **静态生存期**
  - <font color="#dd0000">**对象的生存期与程序的运行期相同**</font>，**则称它具有静态生存期**
  - 在文件作用域中声明的对象都是具有静态生存期的
  - 若在函数内部的局部作用域中声明具有静态生存期的对象，则要使用**static**关键字
    - **局部作用域中静态变量的特点**：
      - 不会随着每次函数调用而产生一个副本，也不会随着函数返回而失效，**该变量会在各次调用间共享**
- **动态生存期**
  - **非静态变量的对象都具有动态生存期**
  - 在局部作用域中声明的具有动态生存期的对象，也称为*局部生存期对象*，它*诞生于声明点，结束于声明所在的块执行完毕之时*

##### 2.2.5.2 类的静态成员

- 特点

  - 用关键字**static**声明
  - **为该类的所有对象共享**，静态数据成员具有**静态生存周期**
  - 必须在**类外定义和初始化**，用 “ :: ” 来指明所属的类
    - “ :: ” 是作用域操作符

- 为什么需要静态数据成员？

  示例：

  一个点类的模板，每新创建一个点类对象都会调用一次上述函数

  ```c++
  #include <iostream>
  using namespace std;
  
  // 一个点类，点的属性：坐标
  class Point{
  private:
      int x, y;
  public:
      Point(int x = 0, int y = 0) : x(x), y(y){ } 
      ~Point() { }
      int getX() { return x; }
      int getY() { return y; }
  };
  ```

  <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/image-20230510093819310.png" alt="image-20230510093819310" style="zoom:30%;" />

  每个类的实例都创建都创建一个独立的对象，每个对象都复制了类的数据或属性

  **每个对象管理各自得属性值**

  - 假设增加一个需求：统计点的总个数

    - 考虑添加一个计数的数据成员用于统计

  - 要求：

    - 必须在任何时候都能在每个Student对象中使用加法函数

    - 当生成一个新的Student实例的时候，必须保证，所有Student对象都实现了总人数的计数

      ```c++
      class Point{
      private:
          int x, y;
          int count;	// 用于记录点的个数
      public:
          Point(int x = 0, int y = 0) : x(x), y(y){ } 
          ~Point() { }
          int getX() { return x; }
          int getY() { return y; }
          
          void addCount() { count++; }
          void showCount() {
              count << " Object count = " << count << endl;
          }
      };
      ```

      <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202206062132913.png" alt="image-20220606213201865" style="zoom:40%;" />

  - 上述代码存在的问题：

    - 每次新定义一个点类，都要手动的修改count值，定义第1个则count改为1，定义第2个则count改为2，同时要将第1个对象的count值改为2，定义第3个则count改为3，同时要将第1个和第2个对象的count值改为3……

  - **解决办法：指定count为一个静态数据成员**

    <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202206062140199.png" alt="image-20220606214017145" style="zoom: 40%;" />

    - **局部静态变量的生存期域程序的运行时间相同**

    - count仍然是局部变量，可以看成是**所有Point对象共享的一般变量**

      ```c++
      class Point{
      private:
          int x, y;
          static int count;	// 静态数据成员声明，用于记录点的个数
      public:
          // 每次创建对象时都会自动调用，自动将对象个数加1
          Point(int x = 0, int y = 0) : x(x), y(y){ count++; } 
          
          // 每次撤销对象的时候自动调用，对象个数自动减1
          ~Point() { count--; }
          
          int getX() { return x; }
          int getY() { return y; }
          
          void showCount() {
              count << " Object count = " << count << endl;
          }
      };
      
      // 静态数据成员在类外定义和初始化，使用类名限定
      int Point::count = 0;
      
      int main() {
          Point a(4, 5);	// 定义对象a，其构造函数会使count加1
          cout << "Point A: " << a.getX() << ", " << a.getY();
          a.showCount();	// 输出对象个数
          
          Point b;	// 定义对象b，其构造函数会使count加1
          cout << "Point B: " << b.getX() << ", " << b.getY();
          b.showCount();	// 输出对象个数
          
          return 0;
      }
      ```

      <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/image-20230510101157944.png" alt="image-20230510101157944" style="zoom:67%;" />

##### 2.2.5.3 静态成员函数

- 所有对象共享同一个函数
- 类外代码可以使用类名和作用域操作符来调用静态成员函数
- <font color="#dd0000">**静态成员函数只能引用属于该类的静态数据成员或静态成员函数**</font>
  - 不可访问非静态成员变量

示例：

```c++
class Point{
private:
    int x, y;
    static int count;	// 静态数据成员声明，用于记录点的个数
public:
    // 每次创建对象时都会自动调用，自动将对象个数加1
    Point(int x = 0, int y = 0) : x(x), y(y){ count++; } 
    // 每次撤销对象的时候自动调用，对象个数自动减1
    ~Point() { count--; }
    
    int getX() { return x; }
    int getY() { return y; }
    
    // 静态成员函数
    static void showCount() {
        count << " Object count = " << count << endl;
    }
};

// 静态数据成员在类外定义和初始化，使用类名限定
int Point::count = 0;

int main() {
    Point a(4, 5);	// 定义对象a，其构造函数会使count加1
    cout << "Point A: " << a.getX() << ", " << a.getY();
    
    // 用类名和作用域操作符在类外调用静态成员函数
    Point::showCount();	// 输出对象个数
    
    Point b;	// 定义对象b，其构造函数会使count加1
    cout << "Point B: " << b.getX() << ", " << b.getY();
    Point::showCount();	// 输出对象个数
    
    return 0;
}
```

### 2.3 对象指针和对象数组

##### 2.3.1 对象指针

- 声明形式：`类名 *对象指针名;`

  ```c++
  Clock c(8, 3, 10);
  Clock *ptr;
  ptr = &c;
  ```

  <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/image-20230510150019734.png" alt="image-20230510150019734" style="zoom:33%;" />

- **通过指针访问对象成员**（一般类的属性都是封装起来的，因此通常是通过指针访问成员函数）

  - `对象指针名->成员名`
  - ``ptr->getHour();`相当于`(*ptr).getHour();`

```c++
// Clock类的定义与之前的一致

int main(){
    Clock c(8, 3, 10);					// 定义并初始化对象c
    
    Clock *ptr = &c;					// 定义对象指针，用c的地址将其初始化
    
    cout << ptr->getHour() << endl;		 // 利用指针访问对象成员
    cout << c.getHour() << endl;		 // 利用对象名访问对象成员
    return 0;
}
```

##### 2.3.2 this指针

1. 问题：
   - **C++中成员函数和成员变量是分开存储的**
   - 每一个非静态成员函数只会诞生一份函数实例，也就是说<font color="#dd0000">**多个同类型的对象会共用一块代码**</font>
     - 例如一个Point点类，包含一个getX函数来获取该点横坐标，如果有多个Point类的对象，并且同时执行getX函数，那么系统就必须要区分每次执行调用该函数的语句时被赋值的数据成员是属于哪一个对象的
     - **这一块代码要如何区分是哪个对象调用自己？？？**

2. 解决方法：**this指针**

   - <font color="#dd0000">**this指针指向被调用的成员函数所属的对象**</font>
     - **this指针是隐含于每一个类的非静态成员函数中的特殊指针**
     - 不需要定义，直接使用即可
   - 明确地**指出了成员函数当前所操作地数据所属的对象**
     - 当通过一个对象调用成员函数时，**系统先将该对象的地址赋给this指针**，然后调用成员函数，成员函数对对象的数据成员进行操作时，就隐含使用了this指针

3. 用途：

   - **当形参和成员变量同名时，可用this指针来区分**（用this指针就便于不用再另起其他变量名进行区分）

     <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202502241750054.png" alt="image-20250224175045995" style="zoom: 50%;" />

     正确的有两种方法：

     <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202502241753240.png" alt="image-20250224175305174" style="zoom:53%;" />

     <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202502241751029.png" alt="image-20250224175147936" style="zoom:47%;" />

   - **在类的非静态成员函数中返回对象本身**，可使用`return *this`

     <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202502241756560.png" alt="image-20250224175658483" style="zoom:50%;" />

```c++
class Person
{
public:
    Person(int age)
    {
        // this指针指向的是被调用的成员函数 所属的对象
        this->age = age;
	}
    
    Person& PersonAddAge(Person &p){
        this->age += age;
        
        // this指向p2的指针, 而*this指向的就是p2这个对象的本体
        return *this;
    }
    
    int age;
};

// 1. 解决名称冲突
void test01()
{
    Person p1(18);	// p1在调用, this就指向p1
    cout << "p1的年龄为: " << p1.age << endl;
}

// 2. 返回对象本身用*this
void test02()
{
    Person p1(10);
    
    Person p2(10);
    // 链式编程思想
    p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(p1);
    
    cout << "p2的年龄为: " << p2.age << endl;
}

int main(){
    test01();
    test02();
}

```

##### 2.3.3 空指针调用成员函数

- C++中空指针也可以调用成员函数，但是需要注意有没有用到this指针
- 若用到this指针，需要加以判断保障代码的健壮性

传入指针为空，还访问其成员会报错

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202502241806396.png" alt="image-20250224180656337" style="zoom:50%;" />

提高代码健壮性

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202502241807701.png" alt="image-20250224180752612" style="zoom:50%;" />

##### 2.3.4 const修饰成员函数

- 成员函数后加const，称为**常函数**

  - **常函数内不可以修改成员属性**

    <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202502241815597.png" alt="image-20250224181556498" style="zoom:50%;" />

  - **成员属性声明时加关键字mutable后，在常函数中依然可以修改**

- 声明对象前加const，称为**常对象**

  - **常对象只能调用常函数**

    <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202502241818497.png" alt="image-20250224181832407" style="zoom: 50%;" />

##### 2.3.5 动态创建对象

- new 类型名T(初始化参数列表)
  - 功能：在程序执行期间，申请用于存放T类型对象的内存空间，并依初值列表赋以初值
  - 结果值：
    - 成功：T类型的指针，指向新分配的内存
    - 失败：抛出异常
- delete 指针p
  - 功能：释放指针p所指向的内存。
    - p必须是new操作的返回值

例子：

```c++
#include <iostream>
using namespace std;

class Point {
private:
    int x, y;
public:
    Point() : x(0), y(0) {
        cout << "Default Constructor called." << endl;
    }
    Point(int x, int y) : x(x), y(y) {
        cout << "Constructor called." << endl;
    }
    ~Point() { cout << "Destructor called." << endl; }
    
    int getX() { return x; }
    int getY() { return y; }
    void move(int newX, int newY) {
        x = newX;
        y = newY;
    } 
};

int main() {
    cout << "Step one: " << endl;
    Point *ptr1 = new Point;		 
    // ptr1定义为Point类指针
    // new Point会调用构造函数创建一个Point对象，没有括号所以是缺省构造函数，然后将该对象的首地址赋给ptr1指针
    // ptr1就指向了这个新创建的Point对象，从而建立了二者之间的联系
    
    delete ptr1;		   // 删除对象，自动调用析构函数
    
    cout << "Step two: " << endl;
    ptr1 = new Point(1, 2); // new Point(1, 2)调用有参构造函数
    delete ptr1;
    
    return 0;
}
```

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/image-20230510153457429.png" alt="image-20230510153457429" style="zoom:50%;" />

##### 2.3.6 申请和释放动态数组

- **分配**：`new 类型名T[数组长度]`
  - 数组长度可以是任何表达式，在运行时计算
- **释放**：`delete[] 数组名p`
  - 释放指针p所指向的数组
  - p必须是用new分配得到的数组首地址

例子：

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/image-20230510154628958.png" alt="image-20230510154628958" style="zoom:40%;" />

```c++
#include <iostream>
using namespace std;

class Point { 同上 }

int main() {
    
    Point *ptr = new Point[2]; 			// 创建对象数组
    
    ptr[0].move(5, 10);				   // 通过指针访问数组元素的成员
    ptr[1].move(15, 20);			   // 通过指针访问数组元素的成员
    cout << "Deleting..." << endl;
    
    delete[] ptr;					  // 删除整个对象数组
    
    return 0;
}

/**********************/
Point ptr[2]; 

// 与Point *ptr = new Point[2]; 效果相同
// 区别：使用静态数组方式，数组长度是固定的，系统自动分配和释放内存
//		采用new则可以任意设置数组长度
```

### 2.4 数据域封装（可参考的类模板代码结构）

1. 封装的含义：

   - **所有属性都是私有的，外部不能直接访问**
   - **提供与属性相关的成员函数，间接访问属性**

2. 模板代码：

   ```c++
   #include <iostream>
   using namespace std;
   
   class Clock {
   private:
       int hour, minute, second;
   public:
       Clock();							  // 声明无参构造函数，用缺省值初始化对象
       Clock(int newH, int newM, int newS);	// 声明有参构造函数，用传入的参数初始化对象
       
       // 内联函数，设置属性的值
       void setHour(int hour) {
           this->hour = hour;	// 将外部传入的值赋给属性
       }
       void setMinute(int minute) {
           this->minute = minute;
       }
       void setSecond(int second) {
           this->second = second;
       }
       // 获得属性的值
       int getHour() {
           return hour;
       }
       int getMinute() {
           return minute;
       }
       int getSecond() {
           return second;
       }
       
       void display() {
           cout << hour << ":" << minute << ":" << second << endl;
       }
   };
   
   // 定义无参构造函数，给hour、minute、second赋初值为1
   Clock::Clock(): hour(1), minute(1), second(1) {  
   }
   /* 推荐写法：
   Clock::Clock() {
       this->hour = 1;
       this->minute = 1;
       this->second = 1;
   }
   */ 
   
   // 定义有参构造函数，给hour、minute、second赋初值为传入的参数值
   Clock::Clock(int newH, int newM, int newS): hour(newH), minute(newM), second(newS) { 
   }
   /* 推荐写法：
   Clock::Clock(int newH, int newM, int newS) {
       this->hour = newH;		// 将传入的hour值赋给hour属性
       this->minute = newM;
       this->second = newS;
   }
   */ 
   
   int main() {
       
       Clock myClock1;		// 定义对象，此时自动调用无参构造函数
       cout << "利用无参构造函数创建的时间对象为：";
       myClock1.display();
       
       Clock myClock2(8, 3, 30);	// 定义对象，此时自动调用有参构造函数
       cout << "利用有参构造函数创建的时间对象为：";
       myClock2.display();
       
       myClock2.setHour(21);
       cout << "修改过的对象的时间为：";
       myClock2.display();    
       
       return 0;
   }
   ```

3. 数据封装的方法

   - **在定义私有数据域的类之外，对象不能通过直接引用访问该数据域**

     ```c++
     // 这两种方式均错误
     myClock.hour = 5;
     hour = myClock.hour;
     ```

   - **为了能够访问私有数据域，可以编写一个成员函数返回数据值（如getHour，getMinute）**

   - **为了能够修改它，可以编写一个成员函数（如setHour，setMinute）进行设置**

     ```c++
     myClock.setHour(5);
     hour = myClock.getHour();
     ```

4. 数据封装的优点

   - **防止对封装数据的越权访问**

     - 如果要隐藏studentID域，实现数据域的保护的方法有：

       - 用private声明这个数据
       - 不要定义getStudentID函数

       ```c++
       class Student {
       private:
           char studentID[20];
           char studentName[20];
           ......
       }
       ```

   - **限制私有特性改变时产生的连锁反应**

     - 属性是私有的，不对外公开，必须要通过getAge函数去读取私有属性（age）的内容

     - 一个信息被隐藏的越好，未来可被修改的权利就更大

       ```c++
       // 修改前的代码
       class Student {
       // 定义了age属性
       private:
           int age;
       public:
           int getAge(){
               return age;
           }
           ...
       }
       
       // 修改后的代码
       // 把age属性替换成出生年、月、日
       class Student {
       private:
           int birthYear;
           int birthMonth;
           int birthDate;
       public:
           int getAge(){
               age = 系统时间 - 出生年、月、日
               return age;
           }
           ...
       }
       
       // 调用代码
       // 修改前后调用代码不需要改变
       Student s;
       int currentAge = s.getAge();
       ```

       <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202206062103205.png" alt="image-20220606210321109" style="zoom: 33%;" />

   - **保持数据的完整性**

     - `birthdate`是私有属性外界可以修改``birthdate`，但是数据的格式必须要符合要求，比如`mm/dd/yyyy`这种，因此可定义一个共有的检查函数`updateBirthdate()`

     - 先对传过来的新修改的`birthdate`值进行格式检查，只有当格式符合要求的时候才可以调用私有成员函数`setBirthdate()`对``birthdate`进行修改

       ```c++
       class Student {
       private:
           char birthdate[12];
           void setBirthdate(char d[]) {
               strcpy(birthdate, d);
           }
       public:
           bool updateBirthdate(char d[]) {
               if(Data format is not mm/dd/yyyy)
                   return false;
               else if(range of mm or dd is wrong)
                   return false;
               else{
                   setBirthdate(d);
                   return true;
               }
           }
       };
       ```

       <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202206062115748.png" alt="image-20220606211500694" style="zoom:50%;" />

### 2.5 友元

> 生活中你的家有客厅（public），有你的卧室（private），客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去，但是，你也可以允许你的好闺蜜好基友进去

- 友元关系：一个类主动声明哪些其他**函数**或者**类**是它的朋友，进而给它们<font color="#dd0000">**提供对本类的访问特许**</font>
  - 一些类中的私有属性想让类外的一些特殊的函数或者其他类进行访问
- 一种数据共享机制
  - **不同类或对象的成员函数之间**
  - **类的成员函数与一般函数之间**

- <font color="#dd0000">友元是C++提供的一种破坏数据封装和数据隐藏的机制，为了确保数据的完整性，及数据封装与隐藏的原则，**建议尽量不使用或少使用友元**</font>

#### 2.5.1 友元函数

- 在类中用关键字 **friend** 修饰的**非成员函数**
  - <font color="#dd0000">友元函数**不是类的内部成员函数**，而是一个类外的函数</font>
  - 在友元函数体内可以通过**对像名**访问类中的private和protected成员
- **在类中声明友元函数原型，在类外定义该友元函数**
- 作用：
  - 增加灵活性，可以在封装和快速性方面做合理选择

示例：

- 建筑物类中，客厅是公有成员，可在类外进行访问，卧室是私有成员，在类外不可访问到

- 在test01中调用建筑物类，访问卧室会报错

  - 程序：

    ```c++
    // 建筑物类
    class Building {
    public:
    	// 构造函数
    	Building() {
    		m_SittingRoom = "客厅";
    		m_BedRoom = "卧室";		
    	}
    public:
    	string m_SittingRoom;	// 客厅，公共属性
    private:
    	string m_BedRoom;		// 卧室，私有属性
    };
    
    // 全局函数
    // 要求能够访问Building类中的公共和私有成员
    void goodGay(Building *building) {
    	cout << "好基友全局函数 正在访问：" << building->m_SittingRoom << endl;  // 公共属性
    	cout << "好基友全局函数 正在访问：" << building->m_BedRoom << endl;		// 私有属性
    }
    
    void test01() {
        
    	Building building;
        
        // 在类外调用建筑物类, 并访问其私有属性
    	goodGay(&building);
    }
    
    int main() {
    	test01();
    }
    ```

- 上述程序存在错误：**类外无法访问私有成员**

  <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202206081024536.png" alt="image-20220608102403432" style="zoom: 67%;" />

- 解决方法：<font color="#dd0000">**定义友元**</font>

  - **在类内声明，类外定义**

  <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/image-20230510110543903.png" alt="image-20230510110543903" style="zoom:50%;" />

  ```c++
  # include <iostream>
  # include <string>
  using namespace std;
  // 建筑物类
  class Building {
  	friend void goodGay(Building* building);
  public:
  	// 构造函数
  	Building() {
  		m_SittingRoom = "客厅";
  		m_BedRoom = "卧室";		
  	}
  public:
  	string m_SittingRoom;	// 客厅
  private:
  	string m_BedRoom;		// 卧室
  };
  
  // 全局函数
  // 要求能够访问Building类中的公共和私有成员
  void goodGay(Building *building) {
  	cout << "好基友全局函数 正在访问：" << building->m_SittingRoom << endl;
  	cout << "好基友全局函数 正在访问：" << building->m_BedRoom << endl;
  }
  
  void test01() {
  	Building building;
  	goodGay(&building);
  }
  
  int main() {
  	test01();
  }
  ```

**其他例子：计算两个点之间的距离**

```c++
#include <iostream>
#include <cmath>

class Point {
private:
    int x, y;
public:
    Point(int x = 0, int y = 0) {
        this->x = x;
        this->y = y;
    }
    int getX(){ return x; }
    int getY(){ return y; }
    
    friend double dist(Point &a, Point &b);	// 类内声明友元函数原型
}

// 类外定义友元函数dist()
// 传入两个Point类对象
double dist(Point& a, Point& b) {
    double x = a.x - b.x;
    double y = a.y - b.y;
    return (sqrt(x*x + y*y));
}

int main(){
    Point p1(1, 1), p2(4, 5);
    cout << "The distance is: ";
    cout << dist(p1, p2) << endl;
    return 0;
}

/************* 不用友元 ***********/
class Point {
private:
    int x, y;
public:
    Point(int x = 0, int y = 0) {
        this->x = x;
        this->y = y;
    }
    int getX(){ return x; }
    int getY(){ return y; }
}
double dist(Point& a, Point& b) {
    double x = a.getX() - b.getX(); // 类Point提供了getX()函数才可以这样
    double y = a.getY() - b.getY();
    return (sqrt(x*x + y*y));
}
```

#### 2.5.2 友元类

- 一个类可以将另一个类声明为友元类
  - **若A类为B类的友元类，则A类的所有成员函数都是B类的友元函数，都可以访问B类的私有和保护成员**
- 注意：
  - **友元关系不能传递**
  - **友元关系是单向的**
  - **友元关系不被继承**

示例：

1. **将一个类定义为另一个类的友元**

   - **将GoodGay类定义为Building类的友元**，使GoodGay类可以访问Building类的私有成员

     ```c++
     # include <iostream>
     # include <string>
     using namespace std;
     
     class Building;		// 类声明
     
     class GoodGay {
     public:
     	// 构造函数
     	GoodGay();
     	void visit();			// 参观函数，访问Building中的属性
     	Building* building;
     };
     
     class Building {
     	// GoodGay类是本类中的好朋友，可以访问本类中的私有成员
     	friend class GoodGay;
     public:
     	// 构造函数
     	Building();
     public:
     	string m_SittingRoom;	// 客厅
     private:
     	string m_BedRoom;		// 卧室
     };
     
     //类外写成员函数（构造函数）
     Building::Building() {
     	m_SittingRoom = "客厅";
     	m_BedRoom = "卧室";
     }
     GoodGay::GoodGay() {
     	//创建建筑物对象
     	building = new Building;
     }
     
     // 参观函数，访问Building中的属性
     void GoodGay::visit() {
     	cout << "好基友全局函数 正在访问：" << building->m_SittingRoom << endl;
     	cout << "好基友全局函数 正在访问：" << building->m_BedRoom << endl;
     }
     
     void test01() {
     	GoodGay gg;
     	gg.visit();
     }
     
     int main() {
     	test01();
     }
     ```

2. **将一个类的成员函数定义为另一个类的友元**

   - GoodGay类中的visit函数定义为Building类的友元，使visit可以访问Building类的私有成员

   - GoodGay类中的visit2()函数不可访问Building类的私有成员

     ```c++
     # include <iostream>
     # include <string>
     using namespace std;
     
     class Building;		// 类声明
     class GoodGay {
     public:
     	// 构造函数
     	GoodGay();
     	void visit();			// 让visit函数可以访问Building中的私有成员
     	void visit2();			// 让visit2函数不可以访问Building中的私有成员
     	Building* building;
     };
     
     class Building {
     	// 让GoodGay类的成员visit函数可以访问Building中的私有成员
     	friend void GoodGay::visit();
     public:
     	// 构造函数
     	Building();
     public:
     	string m_SittingRoom;	// 客厅
     private:
     	string m_BedRoom;		// 卧室
     };
     
     //类外写成员函数（构造函数）
     Building::Building() {
     	m_SittingRoom = "客厅";
     	m_BedRoom = "卧室";
     }
     GoodGay::GoodGay() {
     	//创建建筑物对象
     	building = new Building;
     }
     
     // 参观函数，访问Building中的属性
     void GoodGay::visit() {
     	cout << "好基友全局函数 正在访问：" << building->m_SittingRoom << endl;
     	cout << "好基友全局函数 正在访问：" << building->m_BedRoom << endl;
     }
     
     void GoodGay::visit2() {
     	cout << "好基友全局函数 正在访问：" << building->m_SittingRoom << endl;
     }
     
     void test01() {
     	GoodGay gg;
     	gg.visit();
     	gg.visit2();
     }
     
     int main() {
     	test01();
     }
     ```

     <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202206081029840.png" alt="image-20220608102933786" style="zoom:67%;" />

     <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202206081029361.png" alt="image-20220608102942328" style="zoom:67%;" />



### 2.6 运算符重载

- **对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型**

#### 2.6.1 加号运算符`+`重载

- 实现两个**自定义数据类型相加**的运算

  - 对于内置数据类型（例如int，float等），编译器知道如何进行运算

    ```c++
    int a = 10;
    int b = 10;
    int c = a + b;
    ```

  - 但如果是自定义的数据类型，编译器不一定可进行运算

    ```c++
    class Person {
    public:
    	int m_A;
    	int m_B;
    };
    
    Person p1;
    p1.m_A = 10;
    p1.m_B = 10;
    
    Person p2;
    p2.m_A = 10;
    p2.m_B = 10;
    
    Person p3 = p1 + p2;
    ```

    - 自定义两个Person类对象，二者相加运算会报错

      <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202502251039072.png" alt="image-20250225103932986" style="zoom:33%;" />

  - 解决办法：**可以在Person类的定义中自己写一个成员函数来实现两个对象属性相加后返回新的对象**

    ```c++
    Person PersonAddPerson(Person &p) {
    	Person temp;	// 创建临时对象temp, 此时temp的属性m_A和m_B是未初始化的随机值
    	temp.m_A = this->m_A + p.m_A; // this指向被调用成员函数所属的对象, 此处为p1
    	temp.m_B = this->m_B + p.m_B;
    	return temp;
    }
    
    Person p1;
    p1.m_A = 10;
    p1.m_B = 10;
    
    Person p2;
    p2.m_A = 10;
    p2.m_B = 10;
    
    Person p3 = p1.PersonAddPerson(p2);
    ```

    - **在编译器中，上述解决方法被起了一个通用名称：`operator+`**

    - 将`PersonAddPerson`替换为`operator+`即可将`Person p3 = p1.operator+(p2)`简化为`Person p3 = p1 + p2`

      ```c++
      Person operator+(Person &p) {
      	Person temp;
      	temp.m_A = this->m_A + p.m_A;
      	temp.m_B = this->m_B + p.m_B;
      	return temp;
      }
      
      Person p1;
      p1.m_A = 10;
      p1.m_B = 10;
      
      Person p2;
      p2.m_A = 10;
      p2.m_B = 10;
      
      // 成员函数重载的本质调用
      Person p3 = p1.operator+(p2);
      // 简化为
      Person p3 = p1 + p2;
      ```

  - 另一个方法：**通过全局函数重载+号**

    ```c++
    Person operator+(Person &p1, Person &p2) {
    	Person temp;
    	temp.m_A = p1.m_A + p2.m_A;
    	temp.m_B = p1.m_B + p2.m_B;
    	return temp;
    }
    
    Person p1;
    p1.m_A = 10;
    p1.m_B = 10;
    
    Person p2;
    p2.m_A = 10;
    p2.m_B = 10;
    
    // 全局函数重载的本质调用
    Person p3 = operator+(p1, p2);
    // 简化为
    Person p3 = p1 + p2;
    ```

- 总结：

  - **对于内置的数据类型的表达式的运算符是不可能改变的**
  - **不要滥用运算符重载**

#### 2.6.2 左移运算符`<<`重载

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202502251117054.png" alt="image-20250225111707981" style="zoom: 67%;" />

- **只能通过全局函数进行重载**

  ```c++
  class Person {
  public:
      
      // 利用成员函数重载左移运算符 p.operator<<(cout) 简化 p << cout
      // 不会利用成员函数重载<<运算符, 因为无法实现cout在左侧
  	int m_A;
  	int m_B;
  };
  
  //本质是operator<<(cout, p) 简化 cout << p
  ostream operator<<(ostream &out, Person &p) {
  	out << "m_A = " << p.m_A << "m_B = " << p.m_B;
      return out;
  }
  
  void test01(){
      Person p;
      p.m_A = 10;
      p.m_A = 10;
      
      cout << p << endl;
  }
  
  int main(){
      test01();
  }
  ```



#### 2.6.3 函数调用运算符`()`重载

- 由于重载后使用的方式非常像函数的调用，因此称为**仿函数**
- 仿函数没有固定写法，非常灵活

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202502251141338.png" alt="image-20250225114155263" style="zoom: 62%;" />

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202502251142498.png" alt="image-20250225114219416" style="zoom: 60%;" />



### 2.7 继承









## 一、为什么要用继承

一个简化的Student类

```c++
class Student {
private:
    string name;
    string studentID;
public:
    string getName(){ return name; }
    void setName(string newName) { name = newName; }
    string getStudentID(){ return studentID; }
    void setStudentID(string newID) { studentID = newID; }

};
```

例：

在建模的过程中需要产生新类：研究生类，这个类是学生类的一个特殊类型：

- 一个研究生在进入研究生学习之前需要获得什么学位？
- 这个学生是从什么学院获得的学士学位？

方案一：修改学生类

```c++
class Student {
private:
    string name;
    string studentID;
    
    // 新增
    string undergraduateDegree;
    string undergraduateInstitution;
    bool isGraduateStudent;
    
public:
    string getName(){ return name; }
    void setName(string newName) { name = newName; }
    string getStudentID(){ return studentID; }
    void setStudentID(string newID) { studentID = newID; }
    void displayAllAttributes();
};

void Student::displayAllAttributes(){
    cout << "姓名 = " << name << "学号 = " << studentID << endl;
    if(isGraduateStudent) {
        cout << "毕业院校 = " << undergraduateDegree;
        cout << "毕业院校 = " << undergraduateInstitution;
    }
}
```

问题：

- 学生种类很多的时候，代码会变得冗长
- 每新增一个学生类，就要修改添加很多代码
- **难以编写和维护**

方案二：克隆学生类产生新类

- 将上述Student类克隆出一个GraduateStudent类

```c++
class GraduateStudent {
private:
    string name;
    string studentID;
    
    string undergraduateDegree;
    string undergraduateInstitution;
    ...
```

问题：

- 这是一个非常不好的设计，因为在Student类和GraduateStudent类中包含了太多相同的代码。若将来想修改其中的一个类的属性，则必须两个类同时进行维护

**正确的方案：利用继承**

- 在研究生类中**不必复制学生类中任何属性，因为研究生类已经自动的继承学生类中的属性**

```c++
class Student {
private:
    string name;
    string studentID;
public:
    string getName(){ return name; }
    void setName(string newName) { name = newName; }
    string getStudentID(){ return studentID; }
    void setStudentID(string newID) { studentID = newID; }
};

// 继承
class GraduateStudent:public Student {
private:
    string undergraduateDegree;
    string undergraduateInstitution;
...
}
```

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202206071059120.png" alt="image-20220607105950063" style="zoom:50%;" />

## 二、类的继承与派生

1. 继承和派生是同一过程从不同的角度来看：

   - **继承**：**保持已有类的特性而*构造新类* 的过程**
   - **派生**：**在已有类的基础上新增自己的特性而*产生新类* 的过程**

2. **基类（父类）**：被继承的已有类

   - 直接基类：直接参与派生出某类的基类
   - 间接基类：基类的基类甚至跟高层的基类

3. **派生类（子类）**：派生出的新类

4. 语法：

   ```c++
   class 派生类 ：继承访问控制 基类 {
   public:
       公有成员列表
   protected:
       受保护成员列表
   private:
       私有成员列表    
   }；
   ```

示例：

```c++
// 基类Point类的定义
class Point {
private:
    float x, y;
public:
    void initPoint (float = 0, float y = 0){
        this->x = x;
        this->y = y;
    }
    void move(float offX, float offY){
        x += offX;
        y += offY;
    }
    float getX() { return x; }
    float getY() { return y; }
};

// 派生类定义
class Rectangle: public Point {
private:
    float width, height;
public:
    void initRectangle(float x, float y, float w, float h) {
        initPoint(x, y);	// 调用基类公有成员函数
        this->width = w;
        this->height = h;
    }
    float getHeight() { return height; }
    float getWidth() { return width; }
};
```

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202206071143262.png" alt="image-20220607114312172" style="zoom:40%;" />

## 三、访问控制规则

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202206071110967.png" alt="image-20220607111057897" style="zoom:50%;" />

### 3.1 public继承

- 定义一个父类：

  - 公共、保护、私有属性各有一个

```c++
class Base1 {
public:
	int m_A;
protected:
	int m_B;
private:
	int m_C;
};
```

- 定义一个子类，继承上述父类

```c++
class Son1 : public Base1 {
public:
	void func() {
		m_A = 10;	// 父类的公共权限成员，子类中依旧是公共权限
		m_B = 10;	// 父类的保护权限成员，子类中依旧是保护权限
	}
};
```

- **结论与分析**

  - **父类中的公共权限成员，在子类中依旧是公共权限**

    <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202210170111315.png" alt="image-20221017011152278" style="zoom: 70%;" />

    - 类外可以访问

      <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202210170112405.png" alt="image-20221017011225376" style="zoom: 80%;" />

  - **父类中的保护属性，在子类中依旧是保护属性**

    <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202210170112575.png" alt="image-20221017011255544" style="zoom:67%;" />

  - **父类中的私有属性，在子类中不可访问**

    <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202210170113539.png" alt="image-20221017011319503" style="zoom:67%;" />

### 3.2 protected继承

```c++
class Son2 : protected Base2 {
public:
	void func() {
		m_A = 100;	// 父类的公共权限成员，子类中变成保护权限
		m_B = 100;	// 父类的保护权限成员，子类中依旧是保护权限
		//m_C = 100;	// 父类的私有成员，子类访问不到
	}
};
```

- **m_A在父类中是公共权限成员，类外可以访问，但是子类通过保护继承的方式进行继承，其在子类中变成了保护权限，在类外就无法对其进行访问**

  <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202210170115589.png" alt="image-20221017011518557" style="zoom:67%;" />

- **m_B在父类中是保护权限成员，子类通过保护继承的方式进行继承，其在子类中依旧是保护权限，在类外就无法对其进行访问**

  <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202210170115197.png" alt="image-20221017011535168" style="zoom:67%;" />

### 3.3 private继承

```c++
class Son3 : private Base3 {
public:
	void func() {
		m_A = 100;	// 父类的公共权限成员，子类中变成私有成员
		m_B = 100;	// 父类的保护权限成员，子类中变成私有成员
		//m_C = 100;	// 父类的私有成员，子类访问不到
	}
};
```

- **通过私有继承方式继承，父类中的三种属性成员均会在子类中变成私有属性**

  <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202210170117186.png" alt="image-20221017011732155" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202210170117506.png" alt="image-20221017011748475" style="zoom:80%;" />

## 四、构造函数和析构函数的继承

1. 基类：
   - 基类中的数据成员所构成的部分——基类子对象
   - **基类子对象由基类中声明的构造函数初始化**
2. 派生类：
   - 派生类的对象的数据结构由**基类中声明的数据成员**和**在派生类中声明的数据成员**构成
   - 派生类的构造函数只负责初始化在派生类中声明的数据成员
   - **派生类的构造函数必须通过调用基类的某个构造函数来初始化基类子对象**
   - 不管派生类在类层次上有多少个祖先类，其构造函数只能用其**直接基类**的构造函数
3. <font color="#dd0000">**构造函数不被继承，但可以被调用**</font>
4. 子类继承父类后，当创建子类对象时，也会调用父类的构造函数
   - **先调用父类的构造函数，再调用子类的构造函数**
   - **先调用子类的析构函数，再调用父类的析构函数**

```c++
#include <iostream>
using namespace std;

// 父类Base
class Base {
public:
    Base() { cout << "constructing Base object.\n"; }
    ~Base() { cout << "constructing Base object.\n"; }
};

// 子类Derived
class Derived:public Base{
public:
    Derived(){ cout << "constructing Derived object.\n"; }
    ~Derived(){ cout << "Destructing Derived object.\n"; }
};

int main(){
    // 创建一个Derived类对象，与此同时自动调用Derived的无参构造函数
    // 先调用父类的构造函数，再调用子类的构造函数
    Derived obj;
    
    // 程序结束，自动调用Derived的析构函数，然后再调用父类的析构函数
    // 先调用父类的析构函数，再调用子类的析构函数
    return 0;
}
```

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202206071658081.png" alt="image-20220607165852039" style="zoom:50%;" />

## 五、派生类构造函数

- 派生类构造函数应包括**初始化本身数据成员和基类子对象的形式参数**

- 派生类构造函数实现时**使用初始化列表将基类子对象的参数传递给基类构造函数**

- 实现带初始化列表的派生类构造函数的形式如下：

  ```c++
  派生类名（参数表）：基类名（基类构造函数参数表）{
      派生类构造函数体
  }
  ```


示例：带参数构造函数

```c++
#include <iostream>
using namespace std;

// 父类Base
class Base {
private:
    int base;
public:
    Base();			// 无参构造函数Base
    Base(int base);  // 有参构造函数Base
    ~Base();		// 无参析构函数Base
    
    void print();	// 打印函数
};

Base::Base() {
    base = 0;	// 无参构造函数将私有属性base初始化为0
    cout << "Base's default constructor called." << endl;
}
Base::Base(int base) {
    this->base = base;	// 有参构造函数将传入的base值赋给私有属性base
    cout << "Base's constructor called." << endl;
}
Base::~Base() {
    cout << "Base's destructor called." << endl;
}

void Base::print() {
    cout << "base = " << base << endl;
}

// 子类Derived，继承父类Base
class Derived: public Base {
private:
    int derived;
public:
    Derived();
    Derived(int base, int derived);
    ~Derived();
    
    void print();
};

Derived::~Derived() {
    cout << "Derived's destructor called." << endl;
}
Derived::Derived() {
    derived = 0;
    cout << "Derived's default constructor called." << endl;
}

/* 
“：Base(base)” 表明在准备执行Derived构造函数的时候要先调用Derived的父类Base的有参构造函数Base(int base)，将传入的base值给父类的有参构造函数，然后“derived(derived)”再将传入的参数derived传给子类Derived的私有属性derived 
*/
Derived::Derived(int base, int derived): Base(base), derived(derived) {
    cout << "Derived's constructor called." << endl;
}
void Derived::print() {
    Base::print();
    cout << "derived = " << derived << endl;
}

int main() {
    // 定义子类的对象obj，同时自动调用Derived的有参构造函数，并将参数(5,6)传入
    Derived obj(5, 6);
    obj.print();
    
    // 先调用子类析构函数，再调用父类析构函数
    return 0;
}
```

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202206081517049.png" alt="image-20220608151706989" style="zoom:50%;" />

## 六、派生类析构函数

- **析构函数不被继承，派生类要自行声明**
  - 声明方法与一般类的析构函数相同
- 不需要显式地调用基类地析构函数，系统会自动隐式调用
- **析构函数的调用顺序与构造函数相反**

```c++
#include <iostream>
using namespace std;

class Point {
private:
    float x, y;
public:
    Point() { x = 1; y = 1;}							// 缺省构造函数
    Point(float x, float y) {this->x = x; this->y = y;}	   // 有参构造函数
    ~Point() {}										   // 析构函数
    
    void move(float offX, float offY) { x += offX; y += offY; }
    float getX() { return x; }
    float getY() { return y; }    
    void display() { cout << "x=" << x << "y=" << y; }
};

class Rectangle: public Point {
private:
    float width, height;
public:
    Rectangle();
    rectangle(float x, float y, float w, float h); // 从父类继承了x和y属性，因此要初始化四个参数
    ~Rectangle(){}
    
    float getHeight() { return height; }
    float getWidth() { return width; }
    void display();
};

// 如果省略Point(1,1)，则自动调用无参构造函数
Rectangle::Rectangle():Point(1,1){
    wigth = 1;
    height = 1;
}
// Rectangle类的有参构造函数
Rectangle::Rectangle(float x, float y, float w, float h):Point(x, y){
    width = w;
    height = h;
}

void Rectangle::display() {
    Point::display(); 
    cout << "wigth = " << width << "height = " << height << endl;
}

int main(){
    Rectangle r1;
    r1.display();
    Rectangle r2(3, 3, 5, 6);
    r2.display();
    return 0;
}
```

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/image-20230511113236764.png" alt="image-20230511113236764" style="zoom:50%;" />

## 七、继承同名成员处理方式

当子类和父类出现同名成员，如何通过子类对象，访问到子类或父类中同名成员？

- **访问子类同名成员，直接访问即可**
- **访问父类同名成员，需要加作用域**

1. **访问同名成员变量**

   父类和子类中有一个同名的m_A成员，父类中m_A为100，子类中m_A为200

   ```c++
   class Base {
   public:
   	Base() { m_A = 100; }
   	int m_A;
   };
   
   class Son : public Base {
   public:
   	Son() { m_A = 200; }
   	int m_A;
   };
   ```

   访问子类Son中的m_A：

   ```c++
   void test() {
   	Son s;
   	cout << "m_A = " << s.m_A << endl;
   }
   ```

   通过子类Son对象访问父类Base中的m_A：

   ```c++
   void test() {
   	Son s;
   	cout << "m_A = " << s.Base::m_A << endl;
   }
   ```

   <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/image-20230511153912627.png" alt="image-20230511153912627" style="zoom:50%;" />

2. **访问同名成员函数**

   若子类中出现和父类同名的成员函数，子类的同名函数会隐藏掉父类中所有同名成员函数

   - 若想访问到父类中被隐藏的同名成员函数，需要加作用域

   <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/image-20230511154322411.png" alt="image-20230511154322411" style="zoom:50%;" />

3. **访问同名静态成员**

   - 静态成员变量的属性

     - 所有对象共享同一份数据
     - 编译阶段分配内存
     - 类内声明，类外初始化

   - 静态成员函数的属性

     - 所有对象共享同一个函数
     - 只能访问静态的成员变量

   - **静态成员和非静态成员出现同名，处理方式一致**

     - 静态成员变量

       静态成员类内声明，类外初始化

       ```c++
       class Base {
       public:
       	static int m_A;
       };
       
       int Base::m_A = 100;	// 类内声明，类外初始化
       
       class Son :public Base {
       public:
       	static int m_A;
       };
       
       int Son::m_A = 200;        // 类内声明，类外初始化
       ```

       <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/image-20230511160734010.png" style="zoom:50%;" />

       <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/image-20230511160823479.png" alt="image-20230511160823479" style="zoom:67%;" />

     - 静态成员函数

       ```c++
       class Base {
       public:
       	static int m_A;
           // 静态成员函数
       	static void func() {
       		cout << "Base - static void func()" << endl;
       	}
       
       };
       int Base::m_A = 100;	// 类内声明，类外初始化
       
       class Son :public Base {
       public:
       	static int m_A;
          // 静态成员函数
       	static void func() {
       		cout << "Son - static void func()" << endl;
       	}
       };
       int Son::m_A = 200;
       ```

       <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/image-20230511160909644.png" style="zoom: 80%;" />

       <img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/image-20230511165305724.png" alt="image-20230511165305724" style="zoom:50%;" />

























## 一、类型转换规则

1. **一个公有派生类的对象在使用上可以被当作基类的对象，反之禁止**
   - 派生类的对象可以隐含转换为基类对象
   - 派生类的对象可以初始化基类的引用
   - 派生类的指针可以隐含转换为基类的指针
2. **通过基类对象名，指针只能使用从基类继承的成员**

例1：*父类指针指向子类对象*

```c++
// 基类Base1定义
class Base1 {
public:
    void display() {
        cout << "Base1::display()" << endl;
    }
};

// 基类Base1的子类Base2
class Base2: public Base1 {
public:
    void display() {
        cout << "Base2::display()" << endl;
    }
};

// Base2的子类Derived
class Derived: public Base2 {
public:
    void display(){
        cout << "Derived::display()" << endl;
    }
};

void fun(Base1 *ptr) {
    ptr->display();
}

int main() {
    // 三个类各自声明一个对象
    Base1 base1;
    Base2 base2;
    Derived derived;
    
    fun(&base1);
    fun(&base2); // 将子类对象的地址赋给父类的指针
    fun(&derived);
    
    return 0;
}
```

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202206090013259.png" alt="image-20220609001311213" style="zoom:67%;" />

上述程序是不正确的，正常应该是传入base2的地址，输出Base2::display()，传入derived的地址，输出Derived::display()

`fun(Base1 *ptr)`函数中形参是Base1类的指针，调用时分别传入Base1、Base2和Derived类对象的地址，那么fun函数就会认为这三个对象都是Base1中的

## 二、虚函数定义

- 用**virtual**关键字说明的函数
- 虚函数是**实现运行时多态性基础**
- C++中的虚函数是动态绑定的函数
- 必须是**非静态的成员函数**，**虚函数经过派生后就可以实现运行过程中的多态**

示例：

在上述代码使用虚函数之后：

```c++
class Base1 {
public:
    virtual void display() {
        cout << "Base1::display()" << endl;
    }
};

// 子类继承Base1之后，子类中的display函数也都会变成虚函数
```

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202206090021408.png" alt="image-20220609002108363" style="zoom:67%;" />

## 三、多态

**多态性（Polymorphism）是指*不同类的对象* 对*同一消息* 的*不同响应***

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202206090022027.png" alt="image-20220609002230974" style="zoom: 50%;" />

学生Student有各种属性，如学号、姓名、性别、年龄等等，老师Professor也有各种属性，如编号、职称、姓名、性别、住址、学历等等，在设计的时候*可以将学生和老师的共同属性，如姓名、性别、年龄等，抽取出来形成一个新的类，例如取名为Person类*，在Person类中存放学生Student和老师Professor的共同属性，在学生类Student中保留学生特有的属性，在老师类Professor中也一样。
按照上述思路，即形成一个**继承关系**，Person类是父类，Student类和Professor类是Person类的子类。
进一步的，学生中还可以有不同种类，比如本科生、研究生等，这些学生的共同属性放在Student类中，子类Undergrad、Graduate和Continuing中只包含该类学生特有属性，这样就**进一步得到一个继承关系**。

```c++
Person *pPerson[N];	// 定义一个Person类的指针数组
// 写代码建立下图关系
pPerson[0] = new Student(...);
pPerson[1] = new Professor(...);
......
for(int i = 0; i < N; i++) {
    pPerson[i]->print();	
}
```

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202206102225591.png" alt="image-20220610222508541" style="zoom:50%;" />

- 当循环第1次时，i为0，是学生Student对象，就调用Student类的print函数
- 当循环第2次时，i为1，是老师Professor对象，按理是调用Professor类的print函数，**可Professor类没有定义print函数，但依旧没有关系，Professor类可以去调用从父类Person类继承下来的print函数**
- 当循环第3次时，i为2，是Graduate对象，就调用Graduate类的print函数
- 假设循环第4次时，i为3，是Continuing对象，**Continuing对象没有定义print函数，那么就会调用从它的父类Student的print函数，进一步假设Student类也没有print函数，那么就会继续去调用更高一层的Person类的print函数**
- ……

<font color="#dd0000">**当逐个处理对象集时，每个对象会根据自己的类型和类的内部知识，自动地知道应该执行哪个版本地print()函数。从而采用一种形式*pPerson[i]->print()*，*使不同的对象对同一消息具有不同的响应***</font>

- <font color="#dd0000">**构建一个类似上图的关系图，定义一个所有类的共同父类的指针数组，然后将子类地址赋给父类指针变量**</font>

## 四、动态绑定

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202206102239004.png" alt="image-20220610223941904" style="zoom: 50%;" />

- **静态绑定：程序编译时，可以知道运行结果**
  - 如上述代码，假设是静态绑定，那么编译时，就知道p->print(x,y)是调用那个print函数
- **动态绑定：程序编译时，不知道运行结果**
  - 在编译时，不能预知p指向Student还是指向Professor
  - 在运行时，通过判断p指向的特定对象是什么，从而决定调用哪个版本的print函数

<font color="#dd0000">**实现动态绑定（多态）的要点**</font>：

1. 具有类的继承关系图，这个继承关系中每个类都可以调用一个虚函数；
2. 基础类的指针指向子类对象；
3. 通过基础类的指针调用虚函数。

**只有通过基类的指针或引用调用虚函数时，才会发生动态绑定**

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202206102253240.png" alt="image-20220610225325150" style="zoom:50%;" />

## 五、虚析构函数

- *为什么需要虚析构函数* ：可以防止一些错误的发生















## 一、纯虚函数与抽象类

- 纯虚函数是**一个在基类中声明的虚函数，它在该基类中没有定义具体的操作内容，要求各派生类根据实际需要定义自己的版本**，纯虚函数的声明格式为：

  ```c++
  virtual 函数类型 函数名(参数表)=0;
  ```

- **带有纯虚函数的类称为抽象类**：

  ```c++
  class 类名 {
      virtual 类型 函数名(参数表) = 0;  // 纯虚函数
      ...
  }
  ```

- 作用：

  1. 抽象类为抽象和设计的目的而声明，将有关的数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为。
  2. 对于暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现。

- 注意：

  1. **抽象类只能作为基类来使用**
  2. **不能声明抽象类的对象**
  3. **构造函数不能是虚函数，析构函数可以是虚函数**



## 二、为什么需要抽象类





## 三、抽象类的特点





























































































